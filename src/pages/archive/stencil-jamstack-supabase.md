---
title: "Building JAMStack with Stencil and Su: Dynamic JAMStack with Supabase"
blurb: "Let's build a widget for user comments to our 11ty blog!"
date: 2021-09-29
usePrism: true
tags:
  - articles
  - Stencil
  - jamstack
  - tutorial
---

Despite often being associated with static site generators, JAMstack sites do not need to do be *static.* In situations where prerendered markup does not suffice, dynamic content can be loaded on the client side. This process is known as commonly known as *hydration*. 

Web components are a great fit for hydration, because they allow for compartmentalized zones of dynamic interactivity within otherwise static HTML. 

But don't let me just tell you that! Lets add user generated comments to a JAMstack site with a web component created with Stencil.

## Usage

When I am building a component, I like to start out with writing an example of what the end usage might look like. For our comments component, I want it to have a really simple configuration: all that is required is a unique ID, URL to our backend, and API token for Supabase.

```html
  <my-comments
    id="..."
    supabase-url="..." 
    supabase-key="..."
  ></my-comments>
```
## Stencil Implementation

Let's scaffold out a Stencil component with  `npm run scaffold my-comments` in a new Stencil project. This will set us up with a boilerplate, to which we can add public properties with the `@Prop` decorator and internal state with the `@State` decorator. For more on props and state, check out this prior entry in the Building with Stencil series.

```tsx
  @Component({
    tag: 'my-comments',
    styleUrl: 'my-comments.css',
    shadow: true,
  })
  export class MyComments {

    private supabaseSession: Supabase;

    /** 
     * We don't need a Prop for `id`, since it is a global HTML attribute.
     * Instead, we can get grab it from the HTML element with the @Element decorator.
     */
    @Element() element;

    /**
     * Public URL to the Supabase backend.
     */
    @Prop() supabaseUrl: string;

    /**
     * Public access token to the Supabase backend.
     */
    @Prop() supabaseKey: string;

    /**
     * Comments associated with this block's `id`.
     */
    @State() comments: Comment[] = [];

    /**
     * Value of the new comment text input.
     */
    @State() newCommentValue: string;

    render() {
      //...
    }
  }
```

The `this.comments` array we defined above will hold the comments data loaded from the Supabase backend. Let's define a `Comment` type so that we can utilize Stencil's built in TypeScript support.  

```ts
  type Comment = {
    /*
     * The id of the author who wrote the comment.
     */
    author_id: string;

    /*
     * The body of the comment.
     */
    content: string;

    /*
     * The datetime when the comment was first posted.
     */
    created_at: string;

    /*
     * A unique id for the comment, generated by Supabase.
     */
    id: string;
  }
```

### Rendering a template

Now we are ready to think about what we need to render to the user:
- A list of current comments.
- An input field for adding a new comment.
- An authentication flow. *(Left as an exercise to the reader, but quite easy with Supabase!)*

When building Stencil components with multiple moving parts, I find it helpful to seperate out semantically different templates into multiple render functions. The `renderComment` helper function will be used to render the markup for an individual comment. To make sure the comment is accessible, let's write it as an HTML article element with the ARIA *comment* role. 

```tsx
const renderComment = (comment: Comment) =>
  <article role="comment">
    <header>
      <h1>{comment.author}</h1>
    </header>
    <p>{comment.content}</p>
    <footer>
      <small><time dateTime={comment.created_at}>{format(comment.created_at)}</time></small>
    </footer>
  </article>
```

Now in our `render` function, we can call `renderComment` for each item in the `this.comments` state variable:

```tsx
render() {
  return (
    <Host>
      <h1>Comments</h1>

      {this.comments.map(comment => renderComment(comment))}
    </Host>
  );
}
```

The last thing we need to add to our template is a way for users to add new comments. Let's add a small form with a submit button and a text input that updates the `newCommentValue`.

```tsx
render() {
  return (
    <Host>
      <h2>Comments</h2>

      <form onSubmit={(ev: Event) => this.handleSubmit(ev)}>
        <textarea
          rows={5}
          placeholder="Add a comment..."
          value={this.newCommentValue}
          onChange={(ev: Event) => this.handleChange(ev)}
        ></textarea>
        <input type="submit" value="Submit"/>
      </form>

      {this.comments.map(comment => renderComment(comment))}
    </Host>
  );
}
```

Now we have a shell set up to display our comments, and props and state set up to hold our data. Let's configure Supabase to hold our comment data and wire it up to the compoents lifecycle events. 

## Setting up Supabase

[Supabase](https://supabase.io/) is an open source alternative to Firebase that provides an easy to use interface and API that makes database CRUD operations (creating, reading, updating and deleting) very simple. I have been using it extensively in my personal projects, and I think combining it with Stencil's web components is a wondeful way to create [micro-frontends](https://micro-frontends.org/): dynamic, independent widgets that can be dropped anywhere in a larger project (whether that is a SPA or a static HTML file).

After registering an account and creating a new project, configuring Supabase to work with our frontend only takes a couple of steps.

### Creating a Table to Store Comments

In the Supabase side bar, go to the "Tables" page in the sidebar and then select the `New` button. Lets create a table with fields that match our `Comment` type above. Each field will be a column in the table, and each row will represent a comment.

![Supabase table editor](/files/supacommentsTable.png "Supabase table editor")

### Get the Supabase URL and Key

In the Supabase side bar, go to the "Settings" page in the sidebar and continue to the "API" sub page. There, Supabase exposes two things we need: 

- The "anon" key is the client side api key that allows our frontend to connect to Supabase. This key is safe to share publicly.
- The config URL is the public REST endpoint for our Supabase project.

These values correspond to the `supabaseUrl` and `supabaseKey` props that were added to the component. 

**This tutorial does not cover setting up authetication, also provided by Supabase. Setting up proper authentication is neccessary to prevent unrestricted CRUD access to the database.**

## Connecting Supabase CRUD to Component Lifecycle

We need the component to interact with Supabase in three ways:

- Read comments from the database when first loaded
- Load new comments whenever the database is updated
- Submit a new comment when the user presses the submit button

When I am creating a component, I like to seperate logical tasks like these into their own helper functions.

### Read comments from the database

Supabase 

```ts
  private async getComments() {
    const { data } = await this.supabase
      // Grab data from the 'comments' table.
      .from('comments')
      .select()
      // Only grab data that is associated with this component's `id`.
      .eq('location_id', this.el.id)
      // Order the data such that new comments are the top of the list.
      .order('created_at', { ascending: false });

    // Store the response in the `comments` state variable. 
    this.comments = data;
  }
```

We want to load the state when the component is first loaded, so we can call `getComments` in the `componentWillLoad` lifecycle function.

```ts
  componentWillLoad() {
    this.getComments();
  }
```

### Real time updates from the database

It would be nice if new comments were automatically shown in our comment list. Supabase makes that pretty easy too. 


```ts
  private async watchComments() {
    await this.supabase
      // Only watch updates that match our component's id
      .from(`comments:location_id=eq.${this.el.id}`)
      // When a comment is inserted into the table, update the component state. 
      .on('INSERT', payload => {
        this.comments = [payload.new, ...this.comments];
      })
      .subscribe()
  }
```

This can also be added to the `componentWillLoad` lifecycle function.

```ts
  componentWillLoad() {
    this.getComments();
    this.watchComments();
  }
```

### Add new comment to the database

The last piece of functionality we need is the ability to add new comments.

```ts
  private async addComment() {
    const { data, error } = await this.supabase
      .from('comments')
      .insert([
        {
          content: this.newCommentValue,
          author: this.authorName,
          location_id: this.el.id
          // Supabase will automatically generate `id` and `created_at`
        }
      ]);
    return data;
  }
```

Now, we need to call `addComment` whenever the form in our component's template is submitted. Let's add it to the `handleSubmit` function we created earlier.

```ts
  private handleSubmit(ev: Event) {
    // Prevent the default event behavior to keep the page from refreshing.
    ev.preventDefault();
    this.addComment();
  }
```

## Wrapping up

There are a couple of things not covered in this tutorial that are necessary before the component is ready for public use: authetication, more styles, admin capabilites... If you enjoyed this tutorial, leave a comment below if you would like to see more!

The full project is also available on GitHub.